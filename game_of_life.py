# имплементация игры жизнь Конвея в терминале:
#с помощью юникод символов можно нарисовать прямоугольную область и задать начальное положение симуляции

import time
from os import system
input_cell = '■'        #символ живой для клетки
input_no_cell = '□'     #символ для отсутствия клетки
manual = 0

start_state = ''' 


□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□■■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□■□□■■■□□■□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□


'''



cell = '□'
no_cell = ' '
start_state = start_state.strip()                           #избавляемся от пустоты (пробелов) до и после
game_width = start_state.find('\n')                         #находим конец первой строчки и определяем ширину окна  
start_state = start_state.replace('\n', '')                 #удаляем символ новой строки '\n'
game_height = len(start_state) // game_width                #определяем высоту окна деля длину строки на ширину окна
assert len(start_state) % game_width == 0, 'Неверное окно ввода'
start_state = start_state.replace(input_no_cell, no_cell)   #заменяем □ на ' '
start_state = start_state.replace(input_cell, cell)         #заменяем ■ на □
gen = [list(start_state[i*game_width: (i + 1)*game_width]) for i in range(game_height)] #создаем матрицу(чтобы иметь коордианатную систему)
                                                                                        #с теми длиной и шириной, которые определили ранее


def get_next_gen(gen):                                                                              #функция получения следующего поколения
    next_gen = [[no_cell] * game_width for _ in range(game_height)]
    for i in range(1, len(gen) - 1):
        for j in range(1, len(gen[0]) - 1):
            neighbouring_cells = gen[i - 1][j - 1] + gen[i - 1][j] + gen[i - 1][j + 1] + gen[i][j - 1] + \
            gen[i][j + 1] + gen[i + 1][j - 1] + gen[i + 1][j] + gen[i + 1][j + 1]    #neighbouring cells - клетки вокруг данной, каждая из 8 вручную прописана
            if neighbouring_cells.count(cell) == 3:                                 #если их 3, то рождается новая (замена на '□')
                next_gen[i][j] = cell
            elif neighbouring_cells.count(cell) == 2:                               #если их 2, то сохраняется прежнее положение
                next_gen[i][j] = gen[i][j]
            else:
                next_gen[i][j] = no_cell                                          #ы ином случае, клетка умирает (заменяется на ' ' в данном случае)
    return next_gen


while True:                                                                 #бесконечный цикл
    system('cls')                                                           #вывод матрицы
    for row in gen:                 
        print(*row)
    if manual:                                                              #если стоит настройка "ручной" то ждать нажатия
        input()
    else:
        time.sleep(0.4)                                                     #если manual = 0, то обновлять каждые 0.4 сек
    gen = get_next_gen(gen) 
   

